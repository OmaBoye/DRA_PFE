from django.core.exceptions import ValidationError
from django.db import models
from django.utils import timezone
from django.contrib.auth import get_user_model
User = get_user_model()
from results.models import Result
from django.core.validators import MinValueValidator, MaxValueValidator



class Report(models.Model):
    REPORT_TYPE_CHOICES = [
        ('results', 'Results Report'),
        ('activity', 'Activity Report'),
        ('performance', 'Performance Report'),
    ]

    FORMAT_CHOICES = [
        ('pdf', 'PDF'),
        ('excel', 'Excel'),
        ('csv', 'CSV'),
    ]

    # Report Metadata
    report_type = models.CharField(
        max_length=20,
        choices=REPORT_TYPE_CHOICES,
        default='results'
    )
    format = models.CharField(
        max_length=10,
        choices=FORMAT_CHOICES,
        default='pdf'
    )

    # Date Information
    start_date = models.DateField(default=timezone.now)
    end_date = models.DateField(default=timezone.now)

    # Generator Information - Hybrid Approach
    generated_by_user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='generated_reports',
        verbose_name="Generated by (User)"
    )
    generated_by = models.CharField(
        max_length=100,
        blank=True,
        default='Unknown',
        verbose_name="Generated by (Text)"
    )
    # File Storage
    file = models.FileField(
        upload_to='reports/%Y/%m/%d/',
        null=True,
        blank=True
    )

    # Report Options
    parameters = models.JSONField(default=dict)
    include_details = models.BooleanField(default=False)
    group_by_department = models.BooleanField(default=True)

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Report'
        verbose_name_plural = 'Reports'
        indexes = [
            models.Index(fields=['created_at']),
            models.Index(fields=['report_type']),
            models.Index(fields=['generated_by_user']),
        ]

    def __str__(self):
        return f"{self.get_report_type_display()} - {self.start_date} to {self.end_date}"
    def get_included_results(self):
        """Return the Result objects included in this report"""
        if self.report_type == 'results' and 'selected_results' in self.parameters:
            return Result.objects.filter(id__in=self.parameters['selected_results'])
        return Result.objects.none()

    def save(self, *args, **kwargs):
        """Ensure only one generated_by field is set"""
        if self.generated_by_user and self.generated_by:
            self.generated_by = ""
        super().save(*args, **kwargs)

    @property
    def generator_display(self):
        """Unified property to get the generator's name"""
        if self.generated_by_user:
            return self.generated_by_user.get_full_name() or self.generated_by_user.username
        return self.generated_by or "System"

    def clean(self):
        """Validation logic"""
        super().clean()

        if self.start_date > self.end_date:
            raise ValidationError("End date must be after start date")

        if not self.generated_by_user and not self.generated_by:
            raise ValidationError("Either generated_by_user or generated_by must be set")

    def get_absolute_url(self):
        from django.urls import reverse
        return reverse('reports:detail', args=[str(self.id)])

    @property
    def has_file(self):
        """Check if the report has an associated file"""
        return bool(self.file) and self.file.storage.exists(self.file.name)

    def get_download_url(self):
        """Safe method to get download URL"""
        return self.file.url if self.has_file else None
